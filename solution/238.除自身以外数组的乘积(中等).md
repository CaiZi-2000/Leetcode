# 238.除自身以外数组的乘积(中等)

[题目链接](https://leetcode-cn.com/problems/product-of-array-except-self/)

## 题目描述:

给你一个长度为 *n* 的整数数组 `nums` ，其中 *n* > 1，返回输出数组 `output` ，其中 `output[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。

## 示例:

```
输入: [1,2,3,4]
输出: [24,12,8,6]
```

## 提示:

- 题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。

## 说明:

请**不要使用除法**，且在 O(n) 时间复杂度内完成此题。

## 进阶:

你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组**不被视为**额外空间。）

## 题目分析:

这道题要求我们不使用除法完成，思路其实可以参考 `LeetCode 135.分发糖果(困难)` 。首先，我们可以从左到右遍历一次数组，依次求出当前位左侧元素的乘积存放入数组中，同理，再从右到左遍历一次数组，依次求出当前位右侧元素的乘积存放入另一个数组中。由于边缘元素（即最左和最右的元素）有一侧没有其他元素，所以那一侧首位乘积初始化为 `1` 。最后进行一次循环，把两个数组相同位的数值进行相乘，得到最终的答案（见题解一）。下面的图演示了该过程是如何进行的。

![238_1](https://user-images.githubusercontent.com/57750019/133470542-d412f99e-05dd-4eb3-b460-9efaf45ea266.png)

当然，可以对现在这个方法进行优化（见题解二）。直接创建一个结果数组和一个临时变量，结果数组既当结果返回，又可以先把它看作一个求当前位左侧元素乘积的数组。与上面一样，先从左到右遍历一次数组，依次求出当前位左侧元素的乘积存放入数组中，然后创建一个临时变量，计算和存放右侧所有元素的乘积，首先初始化为 `1` 。然后从右到左遍历数组，把**当前位**的 `所有左侧元素乘积（即结果数组当前位）` 乘以 `在它右侧所有元素的乘积（即临时变量）` 覆盖结果数组当前位，并计算下一位在其右侧所有元素的乘积更新临时变量。下面的图演示了该过程是如何进行的，图中先进行的是结果数组的乘法运算，然后才是图中右侧临时变量的乘法更新运算。

![238_2](https://user-images.githubusercontent.com/57750019/133470563-f35211bf-ee84-406b-b8fb-c6dd8858bfd1.png)

## 题解一:

执行用时: 2 ms

内存消耗: 51.7 MB

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        // 数组长度
        int size = nums.length;
        // 如果长度仅为 2 互换两个数即可
        if (size == 2) {
            return new int[]{nums[1], nums[0]};
        }
        // 结果数组
        int[] res = new int[size];
        // 左右乘积数组
        int[] l = new int[size];
        int[] r = new int[size];
        // 左乘积数组第一个初始化为 1
        l[0] = 1;
        // 遍历数组 求在 i 左侧所有元素的乘积
        for (int i = 1; i < size; ++i) {
            l[i] = nums[i - 1] * l[i - 1];
        }
        // 右乘积数组最后一个初始化为 1
        r[size - 1] = 1;
        // 遍历数组 求在 i 右侧所有元素的乘积
        for (int i = size - 2; i >= 0; --i) {
            r[i] = nums[i + 1] * r[i + 1];
        }
        // 除 nums[i] 之外其余各元素的乘积就是
        // 左侧所有元素的乘积乘以右侧所有元素的乘积
        for (int i = 0; i < size; ++i) {
            res[i] = l[i] * r[i];
        }
        // 返回结果数组
        return res;
    }
}
```

## 题解二:

执行用时: 1 ms

内存消耗: 49.2 MB

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        // 数组长度
        int size = nums.length;
        // 如果长度仅为 2 互换两个数即可
        if (size == 2) {
            return new int[]{nums[1], nums[0]};
        }
        // 结果数组
        int[] res = new int[size];
        // 数组第一个初始化为 1
        res[0] = 1;
        // 遍历数组 求在 i 左侧所有元素的乘积
        for (int i = 1; i < size; ++i) {
            res[i] = nums[i - 1] * res[i - 1];
        }
        // 临时变量计算右侧所有元素的乘积 首先初始化为 1
        int temp = 1;
        // 遍历数组
        for (int i = size - 1; i >= 0; --i) {
            // res[i] 为左侧的乘积 temp 为右侧的乘积
            res[i] = res[i] * temp;
            // 继续计算下一位右侧乘积
            temp *= nums[i];
        }
        // 返回结果数组
        return res;
    }
}
```

题目来源:力扣(LeetCode)
