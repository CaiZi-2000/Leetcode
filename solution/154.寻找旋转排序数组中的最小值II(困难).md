# 154.寻找旋转排序数组中的最小值II(困难)

[题目链接](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)

## 题目描述:

已知一个长度为 ```n``` 的数组，预先按照升序排列，经由 ```1``` 到 ```n``` 次 ```旋转``` 后，得到输入数组。例如，原数组 ```nums = [0,1,4,4,5,6,7]``` 在变化后可能得到：

- 若旋转 ```4``` 次，则可以得到 ```[4,5,6,7,0,1,4]```
- 若旋转 ```7``` 次，则可以得到 ```[0,1,4,4,5,6,7]```

注意，数组 ```[a[0], a[1], a[2], ..., a[n-1]]``` 旋转一次 的结果为数组 ```[a[n-1], a[0], a[1], a[2], ..., a[n-2]]``` 。

给你一个可能存在 ```重复``` 元素值的数组 ```nums``` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 ```最小元素``` 。

## 示例 1:

```
输入：nums = [1,3,5]
输出：1
```

## 示例 2:

```
输入：nums = [2,2,2,0,1]
输出：0
```

## 提示:

- n == nums.length
- 1 <= n <= 5000
- -5000 <= nums[i] <= 5000
- nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转

## 题目分析:

这道题可以采用暴力破解法求解(见题解一)。我们也可以用二分查找法求解。同样的，我们定义左右边界，当左边界小于右边界时循环。然后获取区间中点，比较区间中点值与右边界值的大小。

- 当中点值小于右边界值时，可以得出我们的最小值应该出现在左子区间(包含中点)，我们让右边界更新为中点位置；

![154-1](https://user-images.githubusercontent.com/57750019/132035987-9d28271d-6773-4763-b25e-773e7287bff3.png)

- 当中点值大于右边界值时，可以得出最小值出现在右子区间(肯定不包含中点)，所以我们更新左边界为中点下一个位置；

![154-2](https://user-images.githubusercontent.com/57750019/132036002-93698007-c80a-43e1-bf3a-fbfdfdb36e62.png)

- 当中点值与右边界值刚好相等时，因为数组可以包含相同元素，所以我们不能确定最小值在左子区间还是右子区间，可以让右边界左移一位进行微调，缩小区间范围再进行判断。

![154-3](https://user-images.githubusercontent.com/57750019/132036022-28544ef1-b822-428b-84cf-311d80854318.png)

## 题解一(暴力破解法):

执行用时: 0 ms

内存消耗: 38.3 MB

```java
class Solution {
    public int findMin(int[] nums) {
        // 定义最小值，初始化为数组第一个元素
        int min = nums[0];
        // 遍历数组
        for (int i = 1; i <= nums.length - 1; ++i)
            // 如果当前元素比最小值还小
            if (min > nums[i])
                // 更新最小值为当前元素值
                min = nums[i];
        // 返回数组最小值
        return min;
    }
}
```

## 题解二(二分查找法):

执行用时: 1 ms

内存消耗: 38 MB

```java
class Solution {
    public int findMin(int[] nums) {
        // 定义左右边界
        int left = 0, right = nums.length - 1;
        // 如果左边界小于右边界则执行循环
        while (left < right) {
            // 获取区间中点
            int mid = left + (right - left) / 2;
            // 如果中点值小于右边界值，缩小查找区间至左子区间
            if (nums[mid] < nums[right])
                // 右边界更新为中点
                right = mid;
            // 如果中点值大于右边界值，缩小查找区间至右子区间
            else if (nums[mid] > nums[right])
                // 更新左边界为中点下一个位置
                left = mid + 1;
            // 否则右边界左移一位
            else
                right -= 1;
        }
        // 返回最小值
        return nums[left];
    }
}
```

题目来源:力扣(LeetCode)
