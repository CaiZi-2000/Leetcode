# 169.多数元素(简单)

[题目链接](https://leetcode-cn.com/problems/majority-element/)

## 题目描述:

给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

## 示例 1:

```
输入：[3,2,3]
输出：3
```

## 示例 2:

```
输入：[2,2,1,1,1,2,2]
输出：2
```

## 进阶:

尝试设计时间复杂度为 `O(n)`、空间复杂度为 `O(1)` 的算法解决此问题。

## 题目分析:

这道题可以使用经典的 `Boyer-Moore Majority Vote` 算法来求解。此题可以认为要求的是数组中出现次数最多的元素，也就是众数，而 `Boyer-Moore Majority Vote` 这个算法的一大应用就是求众数。 `Boyer-Moore Majority Vote` 算法是一种用来寻找一组元素中占多数元素的常数空间级时间复杂度算法。这一算法由 Robert S. Boyer 和 J Strother Moore 在1981年发表，也是处理数据流的一种典型算法。该算法出自下面链接的论文(https://www.cs.ou.edu/~rlpage/dmtools/mjrty.pdf) ，论文中也讲了一个例子便于我们理解。在一个数组中，如果把众数记为 `+1` 而把其他数记为 `-1` ，它们的和肯定 `大于 0` 。采用这种思路就可以解决这道题了，创建一个存放和的变量，这里称之为计数器，先把数组中的第一个数当作众数，并用一个临时变量存起来，再继续遍历数组，当下一个数刚好是假设的众数时，计数器加一，否则减一。如果刚好和为 0 ，则更换假设的众数为当前元素，重复这个过程，最后假设的众数就是真正的众数了。这个算法的正确性较难证明，所以这里就不使用数学方法证明了。

## 题解:

执行用时: 1 ms

内存消耗: 44.4 MB

```java
class Solution {
    public int majorityElement(int[] nums) {
        // 计数器
        int count = 0;
        // 众数 先假设为第一个元素
        int x = nums[0];
        // 遍历数组
        for (int num : nums) {
            // 如果计数器值为 0 更换假设的众数
            if (count == 0) {
                x = num;
            }
            // 如果假设的众数值与当前元素值相等计数器就加一 否则减一
            count += (num == x) ? 1 : -1;
        }
        // 最后会得到真正的众数
        return x;
    }
}
```

题目来源:力扣(LeetCode)
