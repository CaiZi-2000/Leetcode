# 693.交替位二进制数(简单)

[题目链接](https://leetcode-cn.com/problems/binary-number-with-alternating-bits/)

## 题目描述:

给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。

## 示例 1:

```
输入：n = 5
输出：true
解释：5 的二进制表示是：101
```

## 示例 2:

```
输入：n = 7
输出：false
解释：7 的二进制表示是：111.
```

## 示例 3:

```
输入：n = 11
输出：false
解释：11 的二进制表示是：1011.
```

## 示例 4:

```
输入：n = 10
输出：true
解释：10 的二进制表示是：1010.
```

## 示例 5:

```
输入：n = 3
输出：false
```

## 提示:
- 1 <= n <= 2^31 - 1

## 题目分析:

这道题可以运用错位异或运算检查其二进制是否 `0` 和 `1` 交替出现。只需要将 `n` 与 `n >> 1` 进行异或运算，如果符合题目要求的交替位二进制，则结果全是 `1` ，将其结果加 `1` 后就会产生一个数，且这个数的二进制形式只含有一个 `1` 。我们只需要把最后这个结果与其减一后的结果进行按位与运算，如果结果为 `0` ，则说明 `n` 的二进制值 `0` 和 `1` 是交替出现的。下面给出了两个例子。

**例子 1** ：n = 101010

|步骤|运算过程|
|:-|-:|
|二进制数 n |101010|
|n ^ (n >> 1)|n：101010<br>n >> 1：10101<br>结果为：111111|
|x = (n ^ (n >> 1)) + 1|1000000|
|x & (x - 1)|x：1000000<br>x - 1：111111<br>结果为：0|

**例子 2** ：n = 101011

|步骤|运算过程|
|:-|-:|
|二进制数 n |101011|
|n ^ (n >> 1)|n：101011<br>n >> 1：10101<br>结果为：111110|
|x = (n ^ (n >> 1)) + 1|111111|
|x & (x - 1)|x：111111<br>x - 1：111110<br>结果为：111110|

## 题解:

执行用时: 0 ms

内存消耗: 35 MB

```java
class Solution {
    public boolean hasAlternatingBits(int n) {
        // 计算 n 右移一位后 按位异或 n 再加上 1 的值
        int x = (n ^ (n >> 1)) + 1;
        // 如果 计算得到的值 与 其减去 1 后的值 按位与 为 0
        // 则说明 n 的二进制值 0 和 1 交替出现
        return (x & (x - 1)) == 0;
    }
}
```

题目来源:力扣(LeetCode)
