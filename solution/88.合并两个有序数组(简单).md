# 88.合并两个有序数组(简单)

[题目链接](https://leetcode-cn.com/problems/merge-sorted-array/)

## 题目描述:

给你两个有序整数数组 ```nums1``` 和 ```nums2``` ，请你将 ```nums2``` 合并到 ```nums1``` 中，使 ```nums1``` 成为一个有序数组。
初始化 ```nums1``` 和 ```nums2``` 的元素数量分别为 ```m``` 和 ```n``` 。你可以假设 ```nums1``` 的空间大小等于 ```m + n```，这样它就有足够的空间保存来自 ```nums2``` 的元素。

## 示例 1:

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

## 示例 2:

```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
```

## 提示:

- nums1.length == m + n
- nums2.length == n
- 0 <= m, n <= 200
- 1 <= m + n <= 200
- -10 的 9 次方 <= nums1[i], nums2[i] <= 10 的 9 次方

## 题目分析:

阅读完这道题，我们很可能想到的不是用双指针解决，而是直接把数组2的数复制到数组1后面，直接对数组1排序就完事了(见题解一)。当然，我们也可以考虑用双指针解决此题。因为两个数组都已经排完序，我们可以直接定义两个指针指向数组的末尾，再定义一个临时指针指向数组1非0元素的末尾，方便我们复制元素。然后我们同时遍历两个数组，将较大的那个数复制到数组1的后面，然后指针向前移动一位，继续重复执行此操作。当然，存在数组1数字全部复制完，但数组2还有剩余元素的情况，我们还需要将数组2剩余的元素复制到数组1中去(见题解二)。

## 题解一:

执行用时: 1 ms

内存消耗: 38.7 MB

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        // 遍历数组2，把数组2的元素复制到数组1后面
        for (int i = 0; i != n; ++i) {
            nums1[m + i] = nums2[i];
        }
        // 最后直接对数组1排序
        Arrays.sort(nums1);
    }
}
```

## 题解二:

执行用时: 0 ms

内存消耗: 38.6 MB

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        // 定义变量存放指针位置，指针指向第一个数组非零元素的末尾，以便复制
        int pos = m + n - 1;
        // 使m指向数组1最后一个元素
        m -= 1;
        // 使n指向数组2最后一个元素
        n -= 1;
        // 同时遍历数组1和数组2
        while ((m >= 0) && (n >= 0))
            // 把数组1和数组2中最大的元素复制给数组1的尾部
            nums1[pos--] = (nums1[m] > nums2[n]) ? nums1[m--] : nums2[n--];
        // 当数组2还有元素没有复制完，因为数组都已排好序，直接追加到数组1前面即可
        while (n >= 0)
            nums1[pos--] = nums2[n--];
    }
}
```

题目来源:力扣(LeetCode)
